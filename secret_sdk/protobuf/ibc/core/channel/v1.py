# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ibc/core/channel/v1/channel.proto, ibc/core/channel/v1/channel_upgrade.proto, ibc/core/channel/v1/tx.proto, ibc/core/channel/v1/genesis.proto, ibc/core/channel/v1/query.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib

from .cosmos.base.query import v1beta1
from .google import protobuf
from .ibc.core.client import v1


class State(betterproto.Enum):
    """
    State defines if a channel is in one of the following states: CLOSED, INIT,
    TRYOPEN, OPEN, FLUSHING, FLUSHCOMPLETE or UNINITIALIZED.
    """

    # Default State
    STATE_UNINITIALIZED_UNSPECIFIED = 0
    # A channel has just started the opening handshake.
    STATE_INIT = 1
    # A channel has acknowledged the handshake step on the counterparty chain.
    STATE_TRYOPEN = 2
    # A channel has completed the handshake. Open channels are ready to send and
    # receive packets.
    STATE_OPEN = 3
    # A channel has been closed and can no longer be used to send or receive
    # packets.
    STATE_CLOSED = 4
    # A channel has just accepted the upgrade handshake attempt and is flushing
    # in-flight packets.
    STATE_FLUSHING = 5
    # A channel has just completed flushing any in-flight packets.
    STATE_FLUSHCOMPLETE = 6


class Order(betterproto.Enum):
    """Order defines if a channel is ORDERED or UNORDERED"""

    # zero-value for channel ordering
    ORDER_NONE_UNSPECIFIED = 0
    # packets can be delivered in any order, which may differ from the order in
    # which they were sent.
    ORDER_UNORDERED = 1
    # packets are delivered exactly in the order which they were sent
    ORDER_ORDERED = 2


class ResponseResultType(betterproto.Enum):
    """
    ResponseResultType defines the possible outcomes of the execution of a
    message
    """

    # Default zero value enumeration
    RESPONSE_RESULT_TYPE_UNSPECIFIED = 0
    # The message did not call the IBC application callbacks (because, for
    # example, the packet had already been relayed)
    RESPONSE_RESULT_TYPE_NOOP = 1
    # The message was executed successfully
    RESPONSE_RESULT_TYPE_SUCCESS = 2
    # The message was executed unsuccessfully
    RESPONSE_RESULT_TYPE_FAILURE = 3


@dataclass
class Channel(betterproto.Message):
    """
    Channel defines pipeline for exactly-once packet delivery between specific
    modules on separate blockchains, which has at least one end capable of
    sending packets and one end capable of receiving packets.
    """

    # current state of the channel end
    state: "State" = betterproto.enum_field(1)
    # whether the channel is ordered or unordered
    ordering: "Order" = betterproto.enum_field(2)
    # counterparty channel end
    counterparty: "Counterparty" = betterproto.message_field(3)
    # list of connection identifiers, in order, along which packets sent on this
    # channel will travel
    connection_hops: List[str] = betterproto.string_field(4)
    # opaque channel version, which is agreed upon during the handshake
    version: str = betterproto.string_field(5)
    # upgrade sequence indicates the latest upgrade attempt performed by this
    # channel the value of 0 indicates the channel has never been upgraded
    upgrade_sequence: int = betterproto.uint64_field(6)


@dataclass
class IdentifiedChannel(betterproto.Message):
    """
    IdentifiedChannel defines a channel with additional port and channel
    identifier fields.
    """

    # current state of the channel end
    state: "State" = betterproto.enum_field(1)
    # whether the channel is ordered or unordered
    ordering: "Order" = betterproto.enum_field(2)
    # counterparty channel end
    counterparty: "Counterparty" = betterproto.message_field(3)
    # list of connection identifiers, in order, along which packets sent on this
    # channel will travel
    connection_hops: List[str] = betterproto.string_field(4)
    # opaque channel version, which is agreed upon during the handshake
    version: str = betterproto.string_field(5)
    # port identifier
    port_id: str = betterproto.string_field(6)
    # channel identifier
    channel_id: str = betterproto.string_field(7)
    # upgrade sequence indicates the latest upgrade attempt performed by this
    # channel the value of 0 indicates the channel has never been upgraded
    upgrade_sequence: int = betterproto.uint64_field(8)


@dataclass
class Counterparty(betterproto.Message):
    """Counterparty defines a channel end counterparty"""

    # port on the counterparty chain which owns the other end of the channel.
    port_id: str = betterproto.string_field(1)
    # channel end on the counterparty chain
    channel_id: str = betterproto.string_field(2)


@dataclass
class Packet(betterproto.Message):
    """
    Packet defines a type that carries data across different chains through IBC
    """

    # number corresponds to the order of sends and receives, where a Packet with
    # an earlier sequence number must be sent and received before a Packet with a
    # later sequence number.
    sequence: int = betterproto.uint64_field(1)
    # identifies the port on the sending chain.
    source_port: str = betterproto.string_field(2)
    # identifies the channel end on the sending chain.
    source_channel: str = betterproto.string_field(3)
    # identifies the port on the receiving chain.
    destination_port: str = betterproto.string_field(4)
    # identifies the channel end on the receiving chain.
    destination_channel: str = betterproto.string_field(5)
    # actual opaque bytes transferred directly to the application module
    data: bytes = betterproto.bytes_field(6)
    # block height after which the packet times out
    timeout_height: v1.Height = betterproto.message_field(7)
    # block timestamp (in nanoseconds) after which the packet times out
    timeout_timestamp: int = betterproto.uint64_field(8)


@dataclass
class PacketState(betterproto.Message):
    """
    PacketState defines the generic type necessary to retrieve and store packet
    commitments, acknowledgements, and receipts. Caller is responsible for
    knowing the context necessary to interpret this state as a commitment,
    acknowledgement, or a receipt.
    """

    # channel port identifier.
    port_id: str = betterproto.string_field(1)
    # channel unique identifier.
    channel_id: str = betterproto.string_field(2)
    # packet sequence.
    sequence: int = betterproto.uint64_field(3)
    # embedded data that represents packet state.
    data: bytes = betterproto.bytes_field(4)


@dataclass
class PacketId(betterproto.Message):
    """
    PacketId is an identifer for a unique Packet Source chains refer to packets
    by source port/channel Destination chains refer to packets by destination
    port/channel
    """

    # channel port identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # packet sequence
    sequence: int = betterproto.uint64_field(3)


@dataclass
class Acknowledgement(betterproto.Message):
    """
    Acknowledgement is the recommended acknowledgement format to be used by
    app-specific protocols. NOTE: The field numbers 21 and 22 were explicitly
    chosen to avoid accidental conflicts with other protobuf message formats
    used for acknowledgements. The first byte of any message with this format
    will be the non-ASCII values `0xaa` (result) or `0xb2` (error). Implemented
    as defined by ICS:
    https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-
    packet-semantics#acknowledgement-envelope
    """

    result: bytes = betterproto.bytes_field(21, group="response")
    error: str = betterproto.string_field(22, group="response")


@dataclass
class Timeout(betterproto.Message):
    """
    Timeout defines an execution deadline structure for 04-channel handlers.
    This includes packet lifecycle handlers as well as the upgrade handshake
    handlers. A valid Timeout contains either one or both of a timestamp and
    block height (sequence).
    """

    # block height after which the packet or upgrade times out
    height: v1.Height = betterproto.message_field(1)
    # block timestamp (in nanoseconds) after which the packet or upgrade times
    # out
    timestamp: int = betterproto.uint64_field(2)


@dataclass
class Params(betterproto.Message):
    """Params defines the set of IBC channel parameters."""

    # the relative timeout after which channel upgrades will time out.
    upgrade_timeout: "Timeout" = betterproto.message_field(1)


@dataclass
class Upgrade(betterproto.Message):
    """
    Upgrade is a verifiable type which contains the relevant information for an
    attempted upgrade. It provides the proposed changes to the channel end, the
    timeout for this upgrade attempt and the next packet sequence which allows
    the counterparty to efficiently know the highest sequence it has received.
    The next sequence send is used for pruning and upgrading from unordered to
    ordered channels.
    """

    fields: "UpgradeFields" = betterproto.message_field(1)
    timeout: "Timeout" = betterproto.message_field(2)
    next_sequence_send: int = betterproto.uint64_field(3)


@dataclass
class UpgradeFields(betterproto.Message):
    """
    UpgradeFields are the fields in a channel end which may be changed during a
    channel upgrade.
    """

    ordering: "Order" = betterproto.enum_field(1)
    connection_hops: List[str] = betterproto.string_field(2)
    version: str = betterproto.string_field(3)


@dataclass
class ErrorReceipt(betterproto.Message):
    """
    ErrorReceipt defines a type which encapsulates the upgrade sequence and
    error associated with the upgrade handshake failure. When a channel upgrade
    handshake is aborted both chains are expected to increment to the next
    sequence.
    """

    # the channel upgrade sequence
    sequence: int = betterproto.uint64_field(1)
    # the error message detailing the cause of failure
    message: str = betterproto.string_field(2)


@dataclass
class MsgChannelOpenInit(betterproto.Message):
    """
    MsgChannelOpenInit defines an sdk.Msg to initialize a channel handshake. It
    is called by a relayer on Chain A.
    """

    port_id: str = betterproto.string_field(1)
    channel: "Channel" = betterproto.message_field(2)
    signer: str = betterproto.string_field(3)


@dataclass
class MsgChannelOpenInitResponse(betterproto.Message):
    """
    MsgChannelOpenInitResponse defines the Msg/ChannelOpenInit response type.
    """

    channel_id: str = betterproto.string_field(1)
    version: str = betterproto.string_field(2)


@dataclass
class MsgChannelOpenTry(betterproto.Message):
    """
    MsgChannelOpenInit defines a msg sent by a Relayer to try to open a channel
    on Chain B. The version field within the Channel field has been deprecated.
    Its value will be ignored by core IBC.
    """

    port_id: str = betterproto.string_field(1)
    # Deprecated: this field is unused. Crossing hello's are no longer supported
    # in core IBC.
    previous_channel_id: str = betterproto.string_field(2)
    # NOTE: the version field within the channel has been deprecated. Its value
    # will be ignored by core IBC.
    channel: "Channel" = betterproto.message_field(3)
    counterparty_version: str = betterproto.string_field(4)
    proof_init: bytes = betterproto.bytes_field(5)
    proof_height: v1.Height = betterproto.message_field(6)
    signer: str = betterproto.string_field(7)


@dataclass
class MsgChannelOpenTryResponse(betterproto.Message):
    """
    MsgChannelOpenTryResponse defines the Msg/ChannelOpenTry response type.
    """

    version: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)


@dataclass
class MsgChannelOpenAck(betterproto.Message):
    """
    MsgChannelOpenAck defines a msg sent by a Relayer to Chain A to acknowledge
    the change of channel state to TRYOPEN on Chain B. WARNING: a channel
    upgrade MUST NOT initialize an upgrade for this channel in the same block
    as executing this message otherwise the counterparty will be incapable of
    opening.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    counterparty_channel_id: str = betterproto.string_field(3)
    counterparty_version: str = betterproto.string_field(4)
    proof_try: bytes = betterproto.bytes_field(5)
    proof_height: v1.Height = betterproto.message_field(6)
    signer: str = betterproto.string_field(7)


@dataclass
class MsgChannelOpenAckResponse(betterproto.Message):
    """
    MsgChannelOpenAckResponse defines the Msg/ChannelOpenAck response type.
    """

    pass


@dataclass
class MsgChannelOpenConfirm(betterproto.Message):
    """
    MsgChannelOpenConfirm defines a msg sent by a Relayer to Chain B to
    acknowledge the change of channel state to OPEN on Chain A.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    proof_ack: bytes = betterproto.bytes_field(3)
    proof_height: v1.Height = betterproto.message_field(4)
    signer: str = betterproto.string_field(5)


@dataclass
class MsgChannelOpenConfirmResponse(betterproto.Message):
    """
    MsgChannelOpenConfirmResponse defines the Msg/ChannelOpenConfirm response
    type.
    """

    pass


@dataclass
class MsgChannelCloseInit(betterproto.Message):
    """
    MsgChannelCloseInit defines a msg sent by a Relayer to Chain A to close a
    channel with Chain B.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    signer: str = betterproto.string_field(3)


@dataclass
class MsgChannelCloseInitResponse(betterproto.Message):
    """
    MsgChannelCloseInitResponse defines the Msg/ChannelCloseInit response type.
    """

    pass


@dataclass
class MsgChannelCloseConfirm(betterproto.Message):
    """
    MsgChannelCloseConfirm defines a msg sent by a Relayer to Chain B to
    acknowledge the change of channel state to CLOSED on Chain A.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    proof_init: bytes = betterproto.bytes_field(3)
    proof_height: v1.Height = betterproto.message_field(4)
    signer: str = betterproto.string_field(5)
    counterparty_upgrade_sequence: int = betterproto.uint64_field(6)


@dataclass
class MsgChannelCloseConfirmResponse(betterproto.Message):
    """
    MsgChannelCloseConfirmResponse defines the Msg/ChannelCloseConfirm response
    type.
    """

    pass


@dataclass
class MsgRecvPacket(betterproto.Message):
    """MsgRecvPacket receives incoming IBC packet"""

    packet: "Packet" = betterproto.message_field(1)
    proof_commitment: bytes = betterproto.bytes_field(2)
    proof_height: v1.Height = betterproto.message_field(3)
    signer: str = betterproto.string_field(4)


@dataclass
class MsgRecvPacketResponse(betterproto.Message):
    """MsgRecvPacketResponse defines the Msg/RecvPacket response type."""

    result: "ResponseResultType" = betterproto.enum_field(1)


@dataclass
class MsgTimeout(betterproto.Message):
    """MsgTimeout receives timed-out packet"""

    packet: "Packet" = betterproto.message_field(1)
    proof_unreceived: bytes = betterproto.bytes_field(2)
    proof_height: v1.Height = betterproto.message_field(3)
    next_sequence_recv: int = betterproto.uint64_field(4)
    signer: str = betterproto.string_field(5)


@dataclass
class MsgTimeoutResponse(betterproto.Message):
    """MsgTimeoutResponse defines the Msg/Timeout response type."""

    result: "ResponseResultType" = betterproto.enum_field(1)


@dataclass
class MsgTimeoutOnClose(betterproto.Message):
    """
    MsgTimeoutOnClose timed-out packet upon counterparty channel closure.
    """

    packet: "Packet" = betterproto.message_field(1)
    proof_unreceived: bytes = betterproto.bytes_field(2)
    proof_close: bytes = betterproto.bytes_field(3)
    proof_height: v1.Height = betterproto.message_field(4)
    next_sequence_recv: int = betterproto.uint64_field(5)
    signer: str = betterproto.string_field(6)
    counterparty_upgrade_sequence: int = betterproto.uint64_field(7)


@dataclass
class MsgTimeoutOnCloseResponse(betterproto.Message):
    """
    MsgTimeoutOnCloseResponse defines the Msg/TimeoutOnClose response type.
    """

    result: "ResponseResultType" = betterproto.enum_field(1)


@dataclass
class MsgAcknowledgement(betterproto.Message):
    """MsgAcknowledgement receives incoming IBC acknowledgement"""

    packet: "Packet" = betterproto.message_field(1)
    acknowledgement: bytes = betterproto.bytes_field(2)
    proof_acked: bytes = betterproto.bytes_field(3)
    proof_height: v1.Height = betterproto.message_field(4)
    signer: str = betterproto.string_field(5)


@dataclass
class MsgAcknowledgementResponse(betterproto.Message):
    """
    MsgAcknowledgementResponse defines the Msg/Acknowledgement response type.
    """

    result: "ResponseResultType" = betterproto.enum_field(1)


@dataclass
class MsgChannelUpgradeInit(betterproto.Message):
    """
    MsgChannelUpgradeInit defines the request type for the ChannelUpgradeInit
    rpc WARNING: Initializing a channel upgrade in the same block as opening
    the channel may result in the counterparty being incapable of opening.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    fields: "UpgradeFields" = betterproto.message_field(3)
    signer: str = betterproto.string_field(4)


@dataclass
class MsgChannelUpgradeInitResponse(betterproto.Message):
    """
    MsgChannelUpgradeInitResponse defines the MsgChannelUpgradeInit response
    type
    """

    upgrade: "Upgrade" = betterproto.message_field(1)
    upgrade_sequence: int = betterproto.uint64_field(2)


@dataclass
class MsgChannelUpgradeTry(betterproto.Message):
    """
    MsgChannelUpgradeTry defines the request type for the ChannelUpgradeTry rpc
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    proposed_upgrade_connection_hops: List[str] = betterproto.string_field(3)
    counterparty_upgrade_fields: "UpgradeFields" = betterproto.message_field(4)
    counterparty_upgrade_sequence: int = betterproto.uint64_field(5)
    proof_channel: bytes = betterproto.bytes_field(6)
    proof_upgrade: bytes = betterproto.bytes_field(7)
    proof_height: v1.Height = betterproto.message_field(8)
    signer: str = betterproto.string_field(9)


@dataclass
class MsgChannelUpgradeTryResponse(betterproto.Message):
    """
    MsgChannelUpgradeTryResponse defines the MsgChannelUpgradeTry response type
    """

    upgrade: "Upgrade" = betterproto.message_field(1)
    upgrade_sequence: int = betterproto.uint64_field(2)
    result: "ResponseResultType" = betterproto.enum_field(3)


@dataclass
class MsgChannelUpgradeAck(betterproto.Message):
    """
    MsgChannelUpgradeAck defines the request type for the ChannelUpgradeAck rpc
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    counterparty_upgrade: "Upgrade" = betterproto.message_field(3)
    proof_channel: bytes = betterproto.bytes_field(4)
    proof_upgrade: bytes = betterproto.bytes_field(5)
    proof_height: v1.Height = betterproto.message_field(6)
    signer: str = betterproto.string_field(7)


@dataclass
class MsgChannelUpgradeAckResponse(betterproto.Message):
    """
    MsgChannelUpgradeAckResponse defines MsgChannelUpgradeAck response type
    """

    result: "ResponseResultType" = betterproto.enum_field(1)


@dataclass
class MsgChannelUpgradeConfirm(betterproto.Message):
    """
    MsgChannelUpgradeConfirm defines the request type for the
    ChannelUpgradeConfirm rpc
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    counterparty_channel_state: "State" = betterproto.enum_field(3)
    counterparty_upgrade: "Upgrade" = betterproto.message_field(4)
    proof_channel: bytes = betterproto.bytes_field(5)
    proof_upgrade: bytes = betterproto.bytes_field(6)
    proof_height: v1.Height = betterproto.message_field(7)
    signer: str = betterproto.string_field(8)


@dataclass
class MsgChannelUpgradeConfirmResponse(betterproto.Message):
    """
    MsgChannelUpgradeConfirmResponse defines MsgChannelUpgradeConfirm response
    type
    """

    result: "ResponseResultType" = betterproto.enum_field(1)


@dataclass
class MsgChannelUpgradeOpen(betterproto.Message):
    """
    MsgChannelUpgradeOpen defines the request type for the ChannelUpgradeOpen
    rpc
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    counterparty_channel_state: "State" = betterproto.enum_field(3)
    counterparty_upgrade_sequence: int = betterproto.uint64_field(4)
    proof_channel: bytes = betterproto.bytes_field(5)
    proof_height: v1.Height = betterproto.message_field(6)
    signer: str = betterproto.string_field(7)


@dataclass
class MsgChannelUpgradeOpenResponse(betterproto.Message):
    """
    MsgChannelUpgradeOpenResponse defines the MsgChannelUpgradeOpen response
    type
    """

    pass


@dataclass
class MsgChannelUpgradeTimeout(betterproto.Message):
    """
    MsgChannelUpgradeTimeout defines the request type for the
    ChannelUpgradeTimeout rpc
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    counterparty_channel: "Channel" = betterproto.message_field(3)
    proof_channel: bytes = betterproto.bytes_field(4)
    proof_height: v1.Height = betterproto.message_field(5)
    signer: str = betterproto.string_field(6)


@dataclass
class MsgChannelUpgradeTimeoutResponse(betterproto.Message):
    """
    MsgChannelUpgradeTimeoutRepsonse defines the MsgChannelUpgradeTimeout
    response type
    """

    pass


@dataclass
class MsgChannelUpgradeCancel(betterproto.Message):
    """
    MsgChannelUpgradeCancel defines the request type for the
    ChannelUpgradeCancel rpc
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    error_receipt: "ErrorReceipt" = betterproto.message_field(3)
    proof_error_receipt: bytes = betterproto.bytes_field(4)
    proof_height: v1.Height = betterproto.message_field(5)
    signer: str = betterproto.string_field(6)


@dataclass
class MsgChannelUpgradeCancelResponse(betterproto.Message):
    """
    MsgChannelUpgradeCancelResponse defines the MsgChannelUpgradeCancel
    response type
    """

    pass


@dataclass
class MsgUpdateParams(betterproto.Message):
    """MsgUpdateParams is the MsgUpdateParams request type."""

    # authority is the address that controls the module (defaults to x/gov unless
    # overwritten).
    authority: str = betterproto.string_field(1)
    # params defines the channel parameters to update. NOTE: All parameters must
    # be supplied.
    params: "Params" = betterproto.message_field(2)


@dataclass
class MsgUpdateParamsResponse(betterproto.Message):
    """MsgUpdateParamsResponse defines the MsgUpdateParams response type."""

    pass


@dataclass
class MsgPruneAcknowledgements(betterproto.Message):
    """
    MsgPruneAcknowledgements defines the request type for the
    PruneAcknowledgements rpc.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    limit: int = betterproto.uint64_field(3)
    signer: str = betterproto.string_field(4)


@dataclass
class MsgPruneAcknowledgementsResponse(betterproto.Message):
    """
    MsgPruneAcknowledgementsResponse defines the response type for the
    PruneAcknowledgements rpc.
    """

    # Number of sequences pruned (includes both packet acknowledgements and
    # packet receipts where appropriate).
    total_pruned_sequences: int = betterproto.uint64_field(1)
    # Number of sequences left after pruning.
    total_remaining_sequences: int = betterproto.uint64_field(2)


@dataclass
class GenesisState(betterproto.Message):
    """GenesisState defines the ibc channel submodule's genesis state."""

    channels: List["IdentifiedChannel"] = betterproto.message_field(1)
    acknowledgements: List["PacketState"] = betterproto.message_field(2)
    commitments: List["PacketState"] = betterproto.message_field(3)
    receipts: List["PacketState"] = betterproto.message_field(4)
    send_sequences: List["PacketSequence"] = betterproto.message_field(5)
    recv_sequences: List["PacketSequence"] = betterproto.message_field(6)
    ack_sequences: List["PacketSequence"] = betterproto.message_field(7)
    # the sequence for the next generated channel identifier
    next_channel_sequence: int = betterproto.uint64_field(8)
    params: "Params" = betterproto.message_field(9)


@dataclass
class PacketSequence(betterproto.Message):
    """
    PacketSequence defines the genesis type necessary to retrieve and store
    next send and receive sequences.
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)
    sequence: int = betterproto.uint64_field(3)


@dataclass
class QueryChannelRequest(betterproto.Message):
    """
    QueryChannelRequest is the request type for the Query/Channel RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)


@dataclass
class QueryChannelResponse(betterproto.Message):
    """
    QueryChannelResponse is the response type for the Query/Channel RPC method.
    Besides the Channel end, it includes a proof and the height from which the
    proof was retrieved.
    """

    # channel associated with the request identifiers
    channel: "Channel" = betterproto.message_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryChannelsRequest(betterproto.Message):
    """
    QueryChannelsRequest is the request type for the Query/Channels RPC method
    """

    # pagination request
    pagination: v1beta1.PageRequest = betterproto.message_field(1)


@dataclass
class QueryChannelsResponse(betterproto.Message):
    """
    QueryChannelsResponse is the response type for the Query/Channels RPC
    method.
    """

    # list of stored channels of the chain.
    channels: List["IdentifiedChannel"] = betterproto.message_field(1)
    # pagination response
    pagination: v1beta1.PageResponse = betterproto.message_field(2)
    # query block height
    height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryConnectionChannelsRequest(betterproto.Message):
    """
    QueryConnectionChannelsRequest is the request type for the
    Query/QueryConnectionChannels RPC method
    """

    # connection unique identifier
    connection: str = betterproto.string_field(1)
    # pagination request
    pagination: v1beta1.PageRequest = betterproto.message_field(2)


@dataclass
class QueryConnectionChannelsResponse(betterproto.Message):
    """
    QueryConnectionChannelsResponse is the Response type for the
    Query/QueryConnectionChannels RPC method
    """

    # list of channels associated with a connection.
    channels: List["IdentifiedChannel"] = betterproto.message_field(1)
    # pagination response
    pagination: v1beta1.PageResponse = betterproto.message_field(2)
    # query block height
    height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryChannelClientStateRequest(betterproto.Message):
    """
    QueryChannelClientStateRequest is the request type for the
    Query/ClientState RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)


@dataclass
class QueryChannelClientStateResponse(betterproto.Message):
    """
    QueryChannelClientStateResponse is the Response type for the
    Query/QueryChannelClientState RPC method
    """

    # client state associated with the channel
    identified_client_state: v1.IdentifiedClientState = betterproto.message_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryChannelConsensusStateRequest(betterproto.Message):
    """
    QueryChannelConsensusStateRequest is the request type for the
    Query/ConsensusState RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # revision number of the consensus state
    revision_number: int = betterproto.uint64_field(3)
    # revision height of the consensus state
    revision_height: int = betterproto.uint64_field(4)


@dataclass
class QueryChannelConsensusStateResponse(betterproto.Message):
    """
    QueryChannelClientStateResponse is the Response type for the
    Query/QueryChannelClientState RPC method
    """

    # consensus state associated with the channel
    consensus_state: protobuf.Any = betterproto.message_field(1)
    # client ID associated with the consensus state
    client_id: str = betterproto.string_field(2)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(3)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(4)


@dataclass
class QueryPacketCommitmentRequest(betterproto.Message):
    """
    QueryPacketCommitmentRequest is the request type for the
    Query/PacketCommitment RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # packet sequence
    sequence: int = betterproto.uint64_field(3)


@dataclass
class QueryPacketCommitmentResponse(betterproto.Message):
    """
    QueryPacketCommitmentResponse defines the client query response for a
    packet which also includes a proof and the height from which the proof was
    retrieved
    """

    # packet associated with the request fields
    commitment: bytes = betterproto.bytes_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryPacketCommitmentsRequest(betterproto.Message):
    """
    QueryPacketCommitmentsRequest is the request type for the
    Query/QueryPacketCommitments RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # pagination request
    pagination: v1beta1.PageRequest = betterproto.message_field(3)


@dataclass
class QueryPacketCommitmentsResponse(betterproto.Message):
    """
    QueryPacketCommitmentsResponse is the request type for the
    Query/QueryPacketCommitments RPC method
    """

    commitments: List["PacketState"] = betterproto.message_field(1)
    # pagination response
    pagination: v1beta1.PageResponse = betterproto.message_field(2)
    # query block height
    height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryPacketReceiptRequest(betterproto.Message):
    """
    QueryPacketReceiptRequest is the request type for the Query/PacketReceipt
    RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # packet sequence
    sequence: int = betterproto.uint64_field(3)


@dataclass
class QueryPacketReceiptResponse(betterproto.Message):
    """
    QueryPacketReceiptResponse defines the client query response for a packet
    receipt which also includes a proof, and the height from which the proof
    was retrieved
    """

    # success flag for if receipt exists
    received: bool = betterproto.bool_field(2)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(3)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(4)


@dataclass
class QueryPacketAcknowledgementRequest(betterproto.Message):
    """
    QueryPacketAcknowledgementRequest is the request type for the
    Query/PacketAcknowledgement RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # packet sequence
    sequence: int = betterproto.uint64_field(3)


@dataclass
class QueryPacketAcknowledgementResponse(betterproto.Message):
    """
    QueryPacketAcknowledgementResponse defines the client query response for a
    packet which also includes a proof and the height from which the proof was
    retrieved
    """

    # packet associated with the request fields
    acknowledgement: bytes = betterproto.bytes_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryPacketAcknowledgementsRequest(betterproto.Message):
    """
    QueryPacketAcknowledgementsRequest is the request type for the
    Query/QueryPacketCommitments RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # pagination request
    pagination: v1beta1.PageRequest = betterproto.message_field(3)
    # list of packet sequences
    packet_commitment_sequences: List[int] = betterproto.uint64_field(4)


@dataclass
class QueryPacketAcknowledgementsResponse(betterproto.Message):
    """
    QueryPacketAcknowledgemetsResponse is the request type for the
    Query/QueryPacketAcknowledgements RPC method
    """

    acknowledgements: List["PacketState"] = betterproto.message_field(1)
    # pagination response
    pagination: v1beta1.PageResponse = betterproto.message_field(2)
    # query block height
    height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryUnreceivedPacketsRequest(betterproto.Message):
    """
    QueryUnreceivedPacketsRequest is the request type for the
    Query/UnreceivedPackets RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # list of packet sequences
    packet_commitment_sequences: List[int] = betterproto.uint64_field(3)


@dataclass
class QueryUnreceivedPacketsResponse(betterproto.Message):
    """
    QueryUnreceivedPacketsResponse is the response type for the
    Query/UnreceivedPacketCommitments RPC method
    """

    # list of unreceived packet sequences
    sequences: List[int] = betterproto.uint64_field(1)
    # query block height
    height: v1.Height = betterproto.message_field(2)


@dataclass
class QueryUnreceivedAcksRequest(betterproto.Message):
    """
    QueryUnreceivedAcks is the request type for the Query/UnreceivedAcks RPC
    method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)
    # list of acknowledgement sequences
    packet_ack_sequences: List[int] = betterproto.uint64_field(3)


@dataclass
class QueryUnreceivedAcksResponse(betterproto.Message):
    """
    QueryUnreceivedAcksResponse is the response type for the
    Query/UnreceivedAcks RPC method
    """

    # list of unreceived acknowledgement sequences
    sequences: List[int] = betterproto.uint64_field(1)
    # query block height
    height: v1.Height = betterproto.message_field(2)


@dataclass
class QueryNextSequenceReceiveRequest(betterproto.Message):
    """
    QueryNextSequenceReceiveRequest is the request type for the
    Query/QueryNextSequenceReceiveRequest RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)


@dataclass
class QueryNextSequenceReceiveResponse(betterproto.Message):
    """
    QuerySequenceResponse is the response type for the
    Query/QueryNextSequenceReceiveResponse RPC method
    """

    # next sequence receive number
    next_sequence_receive: int = betterproto.uint64_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryNextSequenceSendRequest(betterproto.Message):
    """
    QueryNextSequenceSendRequest is the request type for the
    Query/QueryNextSequenceSend RPC method
    """

    # port unique identifier
    port_id: str = betterproto.string_field(1)
    # channel unique identifier
    channel_id: str = betterproto.string_field(2)


@dataclass
class QueryNextSequenceSendResponse(betterproto.Message):
    """
    QueryNextSequenceSendResponse is the request type for the
    Query/QueryNextSequenceSend RPC method
    """

    # next sequence send number
    next_sequence_send: int = betterproto.uint64_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryUpgradeErrorRequest(betterproto.Message):
    """
    QueryUpgradeErrorRequest is the request type for the
    Query/QueryUpgradeError RPC method
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)


@dataclass
class QueryUpgradeErrorResponse(betterproto.Message):
    """
    QueryUpgradeErrorResponse is the response type for the
    Query/QueryUpgradeError RPC method
    """

    error_receipt: "ErrorReceipt" = betterproto.message_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryUpgradeRequest(betterproto.Message):
    """
    QueryUpgradeRequest is the request type for the QueryUpgradeRequest RPC
    method
    """

    port_id: str = betterproto.string_field(1)
    channel_id: str = betterproto.string_field(2)


@dataclass
class QueryUpgradeResponse(betterproto.Message):
    """
    QueryUpgradeResponse is the response type for the QueryUpgradeResponse RPC
    method
    """

    upgrade: "Upgrade" = betterproto.message_field(1)
    # merkle proof of existence
    proof: bytes = betterproto.bytes_field(2)
    # height at which the proof was retrieved
    proof_height: v1.Height = betterproto.message_field(3)


@dataclass
class QueryChannelParamsRequest(betterproto.Message):
    """
    QueryChannelParamsRequest is the request type for the Query/ChannelParams
    RPC method.
    """

    pass


@dataclass
class QueryChannelParamsResponse(betterproto.Message):
    """
    QueryChannelParamsResponse is the response type for the Query/ChannelParams
    RPC method.
    """

    # params defines the parameters of the module.
    params: "Params" = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    """Msg defines the ibc/channel Msg service."""

    async def channel_open_init(
        self,
        *,
        port_id: str = "",
        channel: Optional["Channel"] = None,
        signer: str = "",
    ) -> MsgChannelOpenInitResponse:
        """
        ChannelOpenInit defines a rpc handler method for MsgChannelOpenInit.
        """

        request = MsgChannelOpenInit()
        request.port_id = port_id
        if channel is not None:
            request.channel = channel
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelOpenInit",
            request,
            MsgChannelOpenInitResponse,
        )

    async def channel_open_try(
        self,
        *,
        port_id: str = "",
        previous_channel_id: str = "",
        channel: Optional["Channel"] = None,
        counterparty_version: str = "",
        proof_init: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgChannelOpenTryResponse:
        """
        ChannelOpenTry defines a rpc handler method for MsgChannelOpenTry.
        """

        request = MsgChannelOpenTry()
        request.port_id = port_id
        request.previous_channel_id = previous_channel_id
        if channel is not None:
            request.channel = channel
        request.counterparty_version = counterparty_version
        request.proof_init = proof_init
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelOpenTry",
            request,
            MsgChannelOpenTryResponse,
        )

    async def channel_open_ack(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        counterparty_channel_id: str = "",
        counterparty_version: str = "",
        proof_try: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgChannelOpenAckResponse:
        """
        ChannelOpenAck defines a rpc handler method for MsgChannelOpenAck.
        """

        request = MsgChannelOpenAck()
        request.port_id = port_id
        request.channel_id = channel_id
        request.counterparty_channel_id = counterparty_channel_id
        request.counterparty_version = counterparty_version
        request.proof_try = proof_try
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelOpenAck",
            request,
            MsgChannelOpenAckResponse,
        )

    async def channel_open_confirm(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        proof_ack: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgChannelOpenConfirmResponse:
        """
        ChannelOpenConfirm defines a rpc handler method for
        MsgChannelOpenConfirm.
        """

        request = MsgChannelOpenConfirm()
        request.port_id = port_id
        request.channel_id = channel_id
        request.proof_ack = proof_ack
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelOpenConfirm",
            request,
            MsgChannelOpenConfirmResponse,
        )

    async def channel_close_init(
        self, *, port_id: str = "", channel_id: str = "", signer: str = ""
    ) -> MsgChannelCloseInitResponse:
        """
        ChannelCloseInit defines a rpc handler method for MsgChannelCloseInit.
        """

        request = MsgChannelCloseInit()
        request.port_id = port_id
        request.channel_id = channel_id
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelCloseInit",
            request,
            MsgChannelCloseInitResponse,
        )

    async def channel_close_confirm(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        proof_init: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
        counterparty_upgrade_sequence: int = 0,
    ) -> MsgChannelCloseConfirmResponse:
        """
        ChannelCloseConfirm defines a rpc handler method for
        MsgChannelCloseConfirm.
        """

        request = MsgChannelCloseConfirm()
        request.port_id = port_id
        request.channel_id = channel_id
        request.proof_init = proof_init
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer
        request.counterparty_upgrade_sequence = counterparty_upgrade_sequence

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelCloseConfirm",
            request,
            MsgChannelCloseConfirmResponse,
        )

    async def recv_packet(
        self,
        *,
        packet: Optional["Packet"] = None,
        proof_commitment: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgRecvPacketResponse:
        """RecvPacket defines a rpc handler method for MsgRecvPacket."""

        request = MsgRecvPacket()
        if packet is not None:
            request.packet = packet
        request.proof_commitment = proof_commitment
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/RecvPacket",
            request,
            MsgRecvPacketResponse,
        )

    async def timeout(
        self,
        *,
        packet: Optional["Packet"] = None,
        proof_unreceived: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        next_sequence_recv: int = 0,
        signer: str = "",
    ) -> MsgTimeoutResponse:
        """Timeout defines a rpc handler method for MsgTimeout."""

        request = MsgTimeout()
        if packet is not None:
            request.packet = packet
        request.proof_unreceived = proof_unreceived
        if proof_height is not None:
            request.proof_height = proof_height
        request.next_sequence_recv = next_sequence_recv
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/Timeout",
            request,
            MsgTimeoutResponse,
        )

    async def timeout_on_close(
        self,
        *,
        packet: Optional["Packet"] = None,
        proof_unreceived: bytes = b"",
        proof_close: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        next_sequence_recv: int = 0,
        signer: str = "",
        counterparty_upgrade_sequence: int = 0,
    ) -> MsgTimeoutOnCloseResponse:
        """
        TimeoutOnClose defines a rpc handler method for MsgTimeoutOnClose.
        """

        request = MsgTimeoutOnClose()
        if packet is not None:
            request.packet = packet
        request.proof_unreceived = proof_unreceived
        request.proof_close = proof_close
        if proof_height is not None:
            request.proof_height = proof_height
        request.next_sequence_recv = next_sequence_recv
        request.signer = signer
        request.counterparty_upgrade_sequence = counterparty_upgrade_sequence

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/TimeoutOnClose",
            request,
            MsgTimeoutOnCloseResponse,
        )

    async def acknowledgement(
        self,
        *,
        packet: Optional["Packet"] = None,
        acknowledgement: bytes = b"",
        proof_acked: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgAcknowledgementResponse:
        """
        Acknowledgement defines a rpc handler method for MsgAcknowledgement.
        """

        request = MsgAcknowledgement()
        if packet is not None:
            request.packet = packet
        request.acknowledgement = acknowledgement
        request.proof_acked = proof_acked
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/Acknowledgement",
            request,
            MsgAcknowledgementResponse,
        )

    async def channel_upgrade_init(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        fields: Optional["UpgradeFields"] = None,
        signer: str = "",
    ) -> MsgChannelUpgradeInitResponse:
        """
        ChannelUpgradeInit defines a rpc handler method for
        MsgChannelUpgradeInit.
        """

        request = MsgChannelUpgradeInit()
        request.port_id = port_id
        request.channel_id = channel_id
        if fields is not None:
            request.fields = fields
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelUpgradeInit",
            request,
            MsgChannelUpgradeInitResponse,
        )

    async def channel_upgrade_try(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        proposed_upgrade_connection_hops: List[str] = [],
        counterparty_upgrade_fields: Optional["UpgradeFields"] = None,
        counterparty_upgrade_sequence: int = 0,
        proof_channel: bytes = b"",
        proof_upgrade: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgChannelUpgradeTryResponse:
        """
        ChannelUpgradeTry defines a rpc handler method for
        MsgChannelUpgradeTry.
        """

        request = MsgChannelUpgradeTry()
        request.port_id = port_id
        request.channel_id = channel_id
        request.proposed_upgrade_connection_hops = proposed_upgrade_connection_hops
        if counterparty_upgrade_fields is not None:
            request.counterparty_upgrade_fields = counterparty_upgrade_fields
        request.counterparty_upgrade_sequence = counterparty_upgrade_sequence
        request.proof_channel = proof_channel
        request.proof_upgrade = proof_upgrade
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelUpgradeTry",
            request,
            MsgChannelUpgradeTryResponse,
        )

    async def channel_upgrade_ack(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        counterparty_upgrade: Optional["Upgrade"] = None,
        proof_channel: bytes = b"",
        proof_upgrade: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgChannelUpgradeAckResponse:
        """
        ChannelUpgradeAck defines a rpc handler method for
        MsgChannelUpgradeAck.
        """

        request = MsgChannelUpgradeAck()
        request.port_id = port_id
        request.channel_id = channel_id
        if counterparty_upgrade is not None:
            request.counterparty_upgrade = counterparty_upgrade
        request.proof_channel = proof_channel
        request.proof_upgrade = proof_upgrade
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelUpgradeAck",
            request,
            MsgChannelUpgradeAckResponse,
        )

    async def channel_upgrade_confirm(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        counterparty_channel_state: "State" = 0,
        counterparty_upgrade: Optional["Upgrade"] = None,
        proof_channel: bytes = b"",
        proof_upgrade: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgChannelUpgradeConfirmResponse:
        """
        ChannelUpgradeConfirm defines a rpc handler method for
        MsgChannelUpgradeConfirm.
        """

        request = MsgChannelUpgradeConfirm()
        request.port_id = port_id
        request.channel_id = channel_id
        request.counterparty_channel_state = counterparty_channel_state
        if counterparty_upgrade is not None:
            request.counterparty_upgrade = counterparty_upgrade
        request.proof_channel = proof_channel
        request.proof_upgrade = proof_upgrade
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelUpgradeConfirm",
            request,
            MsgChannelUpgradeConfirmResponse,
        )

    async def channel_upgrade_open(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        counterparty_channel_state: "State" = 0,
        counterparty_upgrade_sequence: int = 0,
        proof_channel: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgChannelUpgradeOpenResponse:
        """
        ChannelUpgradeOpen defines a rpc handler method for
        MsgChannelUpgradeOpen.
        """

        request = MsgChannelUpgradeOpen()
        request.port_id = port_id
        request.channel_id = channel_id
        request.counterparty_channel_state = counterparty_channel_state
        request.counterparty_upgrade_sequence = counterparty_upgrade_sequence
        request.proof_channel = proof_channel
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelUpgradeOpen",
            request,
            MsgChannelUpgradeOpenResponse,
        )

    async def channel_upgrade_timeout(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        counterparty_channel: Optional["Channel"] = None,
        proof_channel: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgChannelUpgradeTimeoutResponse:
        """
        ChannelUpgradeTimeout defines a rpc handler method for
        MsgChannelUpgradeTimeout.
        """

        request = MsgChannelUpgradeTimeout()
        request.port_id = port_id
        request.channel_id = channel_id
        if counterparty_channel is not None:
            request.counterparty_channel = counterparty_channel
        request.proof_channel = proof_channel
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelUpgradeTimeout",
            request,
            MsgChannelUpgradeTimeoutResponse,
        )

    async def channel_upgrade_cancel(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        error_receipt: Optional["ErrorReceipt"] = None,
        proof_error_receipt: bytes = b"",
        proof_height: Optional[v1.Height] = None,
        signer: str = "",
    ) -> MsgChannelUpgradeCancelResponse:
        """
        ChannelUpgradeCancel defines a rpc handler method for
        MsgChannelUpgradeCancel.
        """

        request = MsgChannelUpgradeCancel()
        request.port_id = port_id
        request.channel_id = channel_id
        if error_receipt is not None:
            request.error_receipt = error_receipt
        request.proof_error_receipt = proof_error_receipt
        if proof_height is not None:
            request.proof_height = proof_height
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/ChannelUpgradeCancel",
            request,
            MsgChannelUpgradeCancelResponse,
        )

    async def update_channel_params(
        self, *, authority: str = "", params: Optional["Params"] = None
    ) -> MsgUpdateParamsResponse:
        """
        UpdateChannelParams defines a rpc handler method for MsgUpdateParams.
        """

        request = MsgUpdateParams()
        request.authority = authority
        if params is not None:
            request.params = params

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/UpdateChannelParams",
            request,
            MsgUpdateParamsResponse,
        )

    async def prune_acknowledgements(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        limit: int = 0,
        signer: str = "",
    ) -> MsgPruneAcknowledgementsResponse:
        """
        PruneAcknowledgements defines a rpc handler method for
        MsgPruneAcknowledgements.
        """

        request = MsgPruneAcknowledgements()
        request.port_id = port_id
        request.channel_id = channel_id
        request.limit = limit
        request.signer = signer

        return await self._unary_unary(
            "/ibc.core.channel.v1.Msg/PruneAcknowledgements",
            request,
            MsgPruneAcknowledgementsResponse,
        )


class QueryStub(betterproto.ServiceStub):
    """Query provides defines the gRPC querier service"""

    async def channel(
        self, *, port_id: str = "", channel_id: str = ""
    ) -> QueryChannelResponse:
        """Channel queries an IBC Channel."""

        request = QueryChannelRequest()
        request.port_id = port_id
        request.channel_id = channel_id

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/Channel",
            request,
            QueryChannelResponse,
        )

    async def channels(
        self, *, pagination: Optional[v1beta1.PageRequest] = None
    ) -> QueryChannelsResponse:
        """Channels queries all the IBC channels of a chain."""

        request = QueryChannelsRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/Channels",
            request,
            QueryChannelsResponse,
        )

    async def connection_channels(
        self, *, connection: str = "", pagination: Optional[v1beta1.PageRequest] = None
    ) -> QueryConnectionChannelsResponse:
        """
        ConnectionChannels queries all the channels associated with a
        connection end.
        """

        request = QueryConnectionChannelsRequest()
        request.connection = connection
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/ConnectionChannels",
            request,
            QueryConnectionChannelsResponse,
        )

    async def channel_client_state(
        self, *, port_id: str = "", channel_id: str = ""
    ) -> QueryChannelClientStateResponse:
        """
        ChannelClientState queries for the client state for the channel
        associated with the provided channel identifiers.
        """

        request = QueryChannelClientStateRequest()
        request.port_id = port_id
        request.channel_id = channel_id

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/ChannelClientState",
            request,
            QueryChannelClientStateResponse,
        )

    async def channel_consensus_state(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        revision_number: int = 0,
        revision_height: int = 0,
    ) -> QueryChannelConsensusStateResponse:
        """
        ChannelConsensusState queries for the consensus state for the channel
        associated with the provided channel identifiers.
        """

        request = QueryChannelConsensusStateRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.revision_number = revision_number
        request.revision_height = revision_height

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/ChannelConsensusState",
            request,
            QueryChannelConsensusStateResponse,
        )

    async def packet_commitment(
        self, *, port_id: str = "", channel_id: str = "", sequence: int = 0
    ) -> QueryPacketCommitmentResponse:
        """PacketCommitment queries a stored packet commitment hash."""

        request = QueryPacketCommitmentRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.sequence = sequence

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/PacketCommitment",
            request,
            QueryPacketCommitmentResponse,
        )

    async def packet_commitments(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        pagination: Optional[v1beta1.PageRequest] = None,
    ) -> QueryPacketCommitmentsResponse:
        """
        PacketCommitments returns all the packet commitments hashes associated
        with a channel.
        """

        request = QueryPacketCommitmentsRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/PacketCommitments",
            request,
            QueryPacketCommitmentsResponse,
        )

    async def packet_receipt(
        self, *, port_id: str = "", channel_id: str = "", sequence: int = 0
    ) -> QueryPacketReceiptResponse:
        """
        PacketReceipt queries if a given packet sequence has been received on
        the queried chain
        """

        request = QueryPacketReceiptRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.sequence = sequence

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/PacketReceipt",
            request,
            QueryPacketReceiptResponse,
        )

    async def packet_acknowledgement(
        self, *, port_id: str = "", channel_id: str = "", sequence: int = 0
    ) -> QueryPacketAcknowledgementResponse:
        """
        PacketAcknowledgement queries a stored packet acknowledgement hash.
        """

        request = QueryPacketAcknowledgementRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.sequence = sequence

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/PacketAcknowledgement",
            request,
            QueryPacketAcknowledgementResponse,
        )

    async def packet_acknowledgements(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        pagination: Optional[v1beta1.PageRequest] = None,
        packet_commitment_sequences: List[int] = [],
    ) -> QueryPacketAcknowledgementsResponse:
        """
        PacketAcknowledgements returns all the packet acknowledgements
        associated with a channel.
        """

        request = QueryPacketAcknowledgementsRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        if pagination is not None:
            request.pagination = pagination
        request.packet_commitment_sequences = packet_commitment_sequences

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/PacketAcknowledgements",
            request,
            QueryPacketAcknowledgementsResponse,
        )

    async def unreceived_packets(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        packet_commitment_sequences: List[int] = [],
    ) -> QueryUnreceivedPacketsResponse:
        """
        UnreceivedPackets returns all the unreceived IBC packets associated
        with a channel and sequences.
        """

        request = QueryUnreceivedPacketsRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.packet_commitment_sequences = packet_commitment_sequences

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/UnreceivedPackets",
            request,
            QueryUnreceivedPacketsResponse,
        )

    async def unreceived_acks(
        self,
        *,
        port_id: str = "",
        channel_id: str = "",
        packet_ack_sequences: List[int] = [],
    ) -> QueryUnreceivedAcksResponse:
        """
        UnreceivedAcks returns all the unreceived IBC acknowledgements
        associated with a channel and sequences.
        """

        request = QueryUnreceivedAcksRequest()
        request.port_id = port_id
        request.channel_id = channel_id
        request.packet_ack_sequences = packet_ack_sequences

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/UnreceivedAcks",
            request,
            QueryUnreceivedAcksResponse,
        )

    async def next_sequence_receive(
        self, *, port_id: str = "", channel_id: str = ""
    ) -> QueryNextSequenceReceiveResponse:
        """
        NextSequenceReceive returns the next receive sequence for a given
        channel.
        """

        request = QueryNextSequenceReceiveRequest()
        request.port_id = port_id
        request.channel_id = channel_id

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/NextSequenceReceive",
            request,
            QueryNextSequenceReceiveResponse,
        )

    async def next_sequence_send(
        self, *, port_id: str = "", channel_id: str = ""
    ) -> QueryNextSequenceSendResponse:
        """
        NextSequenceSend returns the next send sequence for a given channel.
        """

        request = QueryNextSequenceSendRequest()
        request.port_id = port_id
        request.channel_id = channel_id

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/NextSequenceSend",
            request,
            QueryNextSequenceSendResponse,
        )

    async def upgrade_error(
        self, *, port_id: str = "", channel_id: str = ""
    ) -> QueryUpgradeErrorResponse:
        """
        UpgradeError returns the error receipt if the upgrade handshake failed.
        """

        request = QueryUpgradeErrorRequest()
        request.port_id = port_id
        request.channel_id = channel_id

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/UpgradeError",
            request,
            QueryUpgradeErrorResponse,
        )

    async def upgrade(
        self, *, port_id: str = "", channel_id: str = ""
    ) -> QueryUpgradeResponse:
        """Upgrade returns the upgrade for a given port and channel id."""

        request = QueryUpgradeRequest()
        request.port_id = port_id
        request.channel_id = channel_id

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/Upgrade",
            request,
            QueryUpgradeResponse,
        )

    async def channel_params(self) -> QueryChannelParamsResponse:
        """
        ChannelParams queries all parameters of the ibc channel submodule.
        """

        request = QueryChannelParamsRequest()

        return await self._unary_unary(
            "/ibc.core.channel.v1.Query/ChannelParams",
            request,
            QueryChannelParamsResponse,
        )
