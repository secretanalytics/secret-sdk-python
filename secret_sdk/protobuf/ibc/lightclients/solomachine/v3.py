# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ibc/lightclients/solomachine/v3/solomachine.proto
# plugin: python-betterproto
from dataclasses import dataclass

import betterproto

from .google import protobuf


@dataclass
class ClientState(betterproto.Message):
    """
    ClientState defines a solo machine client that tracks the current consensus
    state and if the client is frozen.
    """

    # latest sequence of the client state
    sequence: int = betterproto.uint64_field(1)
    # frozen sequence of the solo machine
    is_frozen: bool = betterproto.bool_field(2)
    consensus_state: "ConsensusState" = betterproto.message_field(3)


@dataclass
class ConsensusState(betterproto.Message):
    """
    ConsensusState defines a solo machine consensus state. The sequence of a
    consensus state is contained in the "height" key used in storing the
    consensus state.
    """

    # public key of the solo machine
    public_key: protobuf.Any = betterproto.message_field(1)
    # diversifier allows the same public key to be re-used across different solo
    # machine clients (potentially on different chains) without being considered
    # misbehaviour.
    diversifier: str = betterproto.string_field(2)
    timestamp: int = betterproto.uint64_field(3)


@dataclass
class Header(betterproto.Message):
    """Header defines a solo machine consensus header"""

    timestamp: int = betterproto.uint64_field(1)
    signature: bytes = betterproto.bytes_field(2)
    new_public_key: protobuf.Any = betterproto.message_field(3)
    new_diversifier: str = betterproto.string_field(4)


@dataclass
class Misbehaviour(betterproto.Message):
    """
    Misbehaviour defines misbehaviour for a solo machine which consists of a
    sequence and two signatures over different messages at that sequence.
    """

    sequence: int = betterproto.uint64_field(1)
    signature_one: "SignatureAndData" = betterproto.message_field(2)
    signature_two: "SignatureAndData" = betterproto.message_field(3)


@dataclass
class SignatureAndData(betterproto.Message):
    """
    SignatureAndData contains a signature and the data signed over to create
    that signature.
    """

    signature: bytes = betterproto.bytes_field(1)
    path: bytes = betterproto.bytes_field(2)
    data: bytes = betterproto.bytes_field(3)
    timestamp: int = betterproto.uint64_field(4)


@dataclass
class TimestampedSignatureData(betterproto.Message):
    """
    TimestampedSignatureData contains the signature data and the timestamp of
    the signature.
    """

    signature_data: bytes = betterproto.bytes_field(1)
    timestamp: int = betterproto.uint64_field(2)


@dataclass
class SignBytes(betterproto.Message):
    """SignBytes defines the signed bytes used for signature verification."""

    # the sequence number
    sequence: int = betterproto.uint64_field(1)
    # the proof timestamp
    timestamp: int = betterproto.uint64_field(2)
    # the public key diversifier
    diversifier: str = betterproto.string_field(3)
    # the standardised path bytes
    path: bytes = betterproto.bytes_field(4)
    # the marshaled data bytes
    data: bytes = betterproto.bytes_field(5)


@dataclass
class HeaderData(betterproto.Message):
    """HeaderData returns the SignBytes data for update verification."""

    # header public key
    new_pub_key: protobuf.Any = betterproto.message_field(1)
    # header diversifier
    new_diversifier: str = betterproto.string_field(2)
