# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ibc/applications/transfer/v1/transfer.proto, ibc/applications/transfer/v1/tx.proto, ibc/applications/transfer/v1/authz.proto, ibc/applications/transfer/v1/genesis.proto, ibc/applications/transfer/v1/query.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib

from .cosmos.base import v1beta1
from .cosmos.base.query import v1beta1
from .ibc.core.client import v1


@dataclass
class DenomTrace(betterproto.Message):
    """
    DenomTrace contains the base denomination for ICS20 fungible tokens and the
    source tracing information path.
    """

    # path defines the chain of port/channel identifiers used for tracing the
    # source of the fungible token.
    path: str = betterproto.string_field(1)
    # base denomination of the relayed fungible token.
    base_denom: str = betterproto.string_field(2)


@dataclass
class Params(betterproto.Message):
    """
    Params defines the set of IBC transfer parameters. NOTE: To prevent a
    single token from being transferred, set the TransfersEnabled parameter to
    true and then set the bank module's SendEnabled parameter for the
    denomination to false.
    """

    # send_enabled enables or disables all cross-chain token transfers from this
    # chain.
    send_enabled: bool = betterproto.bool_field(1)
    # receive_enabled enables or disables all cross-chain token transfers to this
    # chain.
    receive_enabled: bool = betterproto.bool_field(2)


@dataclass
class MsgTransfer(betterproto.Message):
    """
    MsgTransfer defines a msg to transfer fungible tokens (i.e Coins) between
    ICS20 enabled chains. See ICS Spec here:
    https://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-
    transfer#data-structures
    """

    # the port on which the packet will be sent
    source_port: str = betterproto.string_field(1)
    # the channel by which the packet will be sent
    source_channel: str = betterproto.string_field(2)
    # the tokens to be transferred
    token: v1beta1.Coin = betterproto.message_field(3)
    # the sender address
    sender: str = betterproto.string_field(4)
    # the recipient address on the destination chain
    receiver: str = betterproto.string_field(5)
    # Timeout height relative to the current block height. The timeout is
    # disabled when set to 0.
    timeout_height: v1.Height = betterproto.message_field(6)
    # Timeout timestamp in absolute nanoseconds since unix epoch. The timeout is
    # disabled when set to 0.
    timeout_timestamp: int = betterproto.uint64_field(7)
    # optional memo
    memo: str = betterproto.string_field(8)


@dataclass
class MsgTransferResponse(betterproto.Message):
    """MsgTransferResponse defines the Msg/Transfer response type."""

    # sequence number of the transfer packet sent
    sequence: int = betterproto.uint64_field(1)


@dataclass
class MsgUpdateParams(betterproto.Message):
    """MsgUpdateParams is the Msg/UpdateParams request type."""

    # signer address
    signer: str = betterproto.string_field(1)
    # params defines the transfer parameters to update. NOTE: All parameters must
    # be supplied.
    params: "Params" = betterproto.message_field(2)


@dataclass
class MsgUpdateParamsResponse(betterproto.Message):
    """
    MsgUpdateParamsResponse defines the response structure for executing a
    MsgUpdateParams message.
    """

    pass


@dataclass
class Allocation(betterproto.Message):
    """Allocation defines the spend limit for a particular port and channel"""

    # the port on which the packet will be sent
    source_port: str = betterproto.string_field(1)
    # the channel by which the packet will be sent
    source_channel: str = betterproto.string_field(2)
    # spend limitation on the channel
    spend_limit: List[v1beta1.Coin] = betterproto.message_field(3)
    # allow list of receivers, an empty allow list permits any receiver address
    allow_list: List[str] = betterproto.string_field(4)
    # allow list of packet data keys, an empty list prohibits all packet data
    # keys; a list only with "*" permits any packet data key
    allowed_packet_data: List[str] = betterproto.string_field(5)


@dataclass
class TransferAuthorization(betterproto.Message):
    """
    TransferAuthorization allows the grantee to spend up to spend_limit coins
    from the granter's account for ibc transfer on a specific channel
    """

    # port and channel amounts
    allocations: List["Allocation"] = betterproto.message_field(1)


@dataclass
class GenesisState(betterproto.Message):
    """GenesisState defines the ibc-transfer genesis state"""

    port_id: str = betterproto.string_field(1)
    denom_traces: List["DenomTrace"] = betterproto.message_field(2)
    params: "Params" = betterproto.message_field(3)
    # total_escrowed contains the total amount of tokens escrowed by the transfer
    # module
    total_escrowed: List[v1beta1.Coin] = betterproto.message_field(4)


@dataclass
class QueryDenomTraceRequest(betterproto.Message):
    """
    QueryDenomTraceRequest is the request type for the Query/DenomTrace RPC
    method
    """

    # hash (in hex format) or denom (full denom with ibc prefix) of the
    # denomination trace information.
    hash: str = betterproto.string_field(1)


@dataclass
class QueryDenomTraceResponse(betterproto.Message):
    """
    QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC
    method.
    """

    # denom_trace returns the requested denomination trace information.
    denom_trace: "DenomTrace" = betterproto.message_field(1)


@dataclass
class QueryDenomTracesRequest(betterproto.Message):
    """
    QueryConnectionsRequest is the request type for the Query/DenomTraces RPC
    method
    """

    # pagination defines an optional pagination for the request.
    pagination: v1beta1.PageRequest = betterproto.message_field(1)


@dataclass
class QueryDenomTracesResponse(betterproto.Message):
    """
    QueryConnectionsResponse is the response type for the Query/DenomTraces RPC
    method.
    """

    # denom_traces returns all denominations trace information.
    denom_traces: List["DenomTrace"] = betterproto.message_field(1)
    # pagination defines the pagination in the response.
    pagination: v1beta1.PageResponse = betterproto.message_field(2)


@dataclass
class QueryParamsRequest(betterproto.Message):
    """
    QueryParamsRequest is the request type for the Query/Params RPC method.
    """

    pass


@dataclass
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is the response type for the Query/Params RPC method.
    """

    # params defines the parameters of the module.
    params: "Params" = betterproto.message_field(1)


@dataclass
class QueryDenomHashRequest(betterproto.Message):
    """
    QueryDenomHashRequest is the request type for the Query/DenomHash RPC
    method
    """

    # The denomination trace ([port_id]/[channel_id])+/[denom]
    trace: str = betterproto.string_field(1)


@dataclass
class QueryDenomHashResponse(betterproto.Message):
    """
    QueryDenomHashResponse is the response type for the Query/DenomHash RPC
    method.
    """

    # hash (in hex format) of the denomination trace information.
    hash: str = betterproto.string_field(1)


@dataclass
class QueryEscrowAddressRequest(betterproto.Message):
    """
    QueryEscrowAddressRequest is the request type for the EscrowAddress RPC
    method.
    """

    # unique port identifier
    port_id: str = betterproto.string_field(1)
    # unique channel identifier
    channel_id: str = betterproto.string_field(2)


@dataclass
class QueryEscrowAddressResponse(betterproto.Message):
    """
    QueryEscrowAddressResponse is the response type of the EscrowAddress RPC
    method.
    """

    # the escrow account address
    escrow_address: str = betterproto.string_field(1)


@dataclass
class QueryTotalEscrowForDenomRequest(betterproto.Message):
    """
    QueryTotalEscrowForDenomRequest is the request type for TotalEscrowForDenom
    RPC method.
    """

    denom: str = betterproto.string_field(1)


@dataclass
class QueryTotalEscrowForDenomResponse(betterproto.Message):
    """
    QueryTotalEscrowForDenomResponse is the response type for
    TotalEscrowForDenom RPC method.
    """

    amount: v1beta1.Coin = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    """Msg defines the ibc/transfer Msg service."""

    async def transfer(
        self,
        *,
        source_port: str = "",
        source_channel: str = "",
        token: Optional[v1beta1.Coin] = None,
        sender: str = "",
        receiver: str = "",
        timeout_height: Optional[v1.Height] = None,
        timeout_timestamp: int = 0,
        memo: str = "",
    ) -> MsgTransferResponse:
        """Transfer defines a rpc handler method for MsgTransfer."""

        request = MsgTransfer()
        request.source_port = source_port
        request.source_channel = source_channel
        if token is not None:
            request.token = token
        request.sender = sender
        request.receiver = receiver
        if timeout_height is not None:
            request.timeout_height = timeout_height
        request.timeout_timestamp = timeout_timestamp
        request.memo = memo

        return await self._unary_unary(
            "/ibc.applications.transfer.v1.Msg/Transfer",
            request,
            MsgTransferResponse,
        )

    async def update_params(
        self, *, signer: str = "", params: Optional["Params"] = None
    ) -> MsgUpdateParamsResponse:
        """UpdateParams defines a rpc handler for MsgUpdateParams."""

        request = MsgUpdateParams()
        request.signer = signer
        if params is not None:
            request.params = params

        return await self._unary_unary(
            "/ibc.applications.transfer.v1.Msg/UpdateParams",
            request,
            MsgUpdateParamsResponse,
        )


class QueryStub(betterproto.ServiceStub):
    """Query provides defines the gRPC querier service."""

    async def denom_traces(
        self, *, pagination: Optional[v1beta1.PageRequest] = None
    ) -> QueryDenomTracesResponse:
        """DenomTraces queries all denomination traces."""

        request = QueryDenomTracesRequest()
        if pagination is not None:
            request.pagination = pagination

        return await self._unary_unary(
            "/ibc.applications.transfer.v1.Query/DenomTraces",
            request,
            QueryDenomTracesResponse,
        )

    async def denom_trace(self, *, hash: str = "") -> QueryDenomTraceResponse:
        """DenomTrace queries a denomination trace information."""

        request = QueryDenomTraceRequest()
        request.hash = hash

        return await self._unary_unary(
            "/ibc.applications.transfer.v1.Query/DenomTrace",
            request,
            QueryDenomTraceResponse,
        )

    async def params(self) -> QueryParamsResponse:
        """Params queries all parameters of the ibc-transfer module."""

        request = QueryParamsRequest()

        return await self._unary_unary(
            "/ibc.applications.transfer.v1.Query/Params",
            request,
            QueryParamsResponse,
        )

    async def denom_hash(self, *, trace: str = "") -> QueryDenomHashResponse:
        """DenomHash queries a denomination hash information."""

        request = QueryDenomHashRequest()
        request.trace = trace

        return await self._unary_unary(
            "/ibc.applications.transfer.v1.Query/DenomHash",
            request,
            QueryDenomHashResponse,
        )

    async def escrow_address(
        self, *, port_id: str = "", channel_id: str = ""
    ) -> QueryEscrowAddressResponse:
        """
        EscrowAddress returns the escrow address for a particular port and
        channel id.
        """

        request = QueryEscrowAddressRequest()
        request.port_id = port_id
        request.channel_id = channel_id

        return await self._unary_unary(
            "/ibc.applications.transfer.v1.Query/EscrowAddress",
            request,
            QueryEscrowAddressResponse,
        )

    async def total_escrow_for_denom(
        self, *, denom: str = ""
    ) -> QueryTotalEscrowForDenomResponse:
        """
        TotalEscrowForDenom returns the total amount of tokens in escrow based
        on the denom.
        """

        request = QueryTotalEscrowForDenomRequest()
        request.denom = denom

        return await self._unary_unary(
            "/ibc.applications.transfer.v1.Query/TotalEscrowForDenom",
            request,
            QueryTotalEscrowForDenomResponse,
        )
