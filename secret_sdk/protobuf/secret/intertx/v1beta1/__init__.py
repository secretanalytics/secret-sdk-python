# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: secret/intertx/v1beta1/query.proto, secret/intertx/v1beta1/tx.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    Optional,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class MsgRegisterAccount(betterproto.Message):
    """
    MsgRegisterAccount registers an interchain account for the given owner over
    the specified connection pair
    """

    owner: str = betterproto.string_field(1)
    connection_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class MsgRegisterAccountResponse(betterproto.Message):
    """
    MsgRegisterAccountResponse is the response type for Msg/RegisterAccount
    """

    pass


@dataclass(eq=False, repr=False)
class MsgSubmitTx(betterproto.Message):
    """
    MsgSubmitTx creates and submits an arbitrary transaction msg to be executed
    using an interchain account
    """

    owner: bytes = betterproto.bytes_field(1)
    connection_id: str = betterproto.string_field(2)
    msg: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class MsgSubmitTxResponse(betterproto.Message):
    """MsgSubmitTxResponse defines the MsgSubmitTx response type"""

    pass


@dataclass(eq=False, repr=False)
class QueryInterchainAccountFromAddressRequest(betterproto.Message):
    """
    QueryInterchainAccountFromAddressRequest is the request type for the
    Query/InterchainAccountAddress RPC
    """

    owner: str = betterproto.string_field(1)
    connection_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryInterchainAccountFromAddressResponse(betterproto.Message):
    """
    QueryInterchainAccountFromAddressResponse the response type for the
    Query/InterchainAccountAddress RPC
    """

    interchain_account_address: str = betterproto.string_field(1)


class MsgStub(betterproto.ServiceStub):
    async def register_account(
        self,
        msg_register_account: "MsgRegisterAccount",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgRegisterAccountResponse":
        return await self._unary_unary(
            "/secret.intertx.v1beta1.Msg/RegisterAccount",
            msg_register_account,
            MsgRegisterAccountResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def submit_tx(
        self,
        msg_submit_tx: "MsgSubmitTx",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgSubmitTxResponse":
        return await self._unary_unary(
            "/secret.intertx.v1beta1.Msg/SubmitTx",
            msg_submit_tx,
            MsgSubmitTxResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryStub(betterproto.ServiceStub):
    async def interchain_account_from_address(
        self,
        query_interchain_account_from_address_request: "QueryInterchainAccountFromAddressRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryInterchainAccountFromAddressResponse":
        return await self._unary_unary(
            "/secret.intertx.v1beta1.Query/InterchainAccountFromAddress",
            query_interchain_account_from_address_request,
            QueryInterchainAccountFromAddressResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgBase(ServiceBase):
    async def register_account(
        self, msg_register_account: "MsgRegisterAccount"
    ) -> "MsgRegisterAccountResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def submit_tx(self, msg_submit_tx: "MsgSubmitTx") -> "MsgSubmitTxResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_register_account(
        self,
        stream: "grpclib.server.Stream[MsgRegisterAccount, MsgRegisterAccountResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.register_account(request)
        await stream.send_message(response)

    async def __rpc_submit_tx(
        self, stream: "grpclib.server.Stream[MsgSubmitTx, MsgSubmitTxResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.submit_tx(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/secret.intertx.v1beta1.Msg/RegisterAccount": grpclib.const.Handler(
                self.__rpc_register_account,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgRegisterAccount,
                MsgRegisterAccountResponse,
            ),
            "/secret.intertx.v1beta1.Msg/SubmitTx": grpclib.const.Handler(
                self.__rpc_submit_tx,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSubmitTx,
                MsgSubmitTxResponse,
            ),
        }


class QueryBase(ServiceBase):
    async def interchain_account_from_address(
        self,
        query_interchain_account_from_address_request: "QueryInterchainAccountFromAddressRequest",
    ) -> "QueryInterchainAccountFromAddressResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_interchain_account_from_address(
        self,
        stream: "grpclib.server.Stream[QueryInterchainAccountFromAddressRequest, QueryInterchainAccountFromAddressResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.interchain_account_from_address(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/secret.intertx.v1beta1.Query/InterchainAccountFromAddress": grpclib.const.Handler(
                self.__rpc_interchain_account_from_address,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryInterchainAccountFromAddressRequest,
                QueryInterchainAccountFromAddressResponse,
            ),
        }
