# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: secret/compute/v1beta1/msg.proto, secret/compute/v1beta1/types.proto, secret/compute/v1beta1/genesis.proto, secret/compute/v1beta1/query.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto
import grpclib

from .cosmos.base import v1beta1
from .cosmos.base.abci import v1beta1
from .google import protobuf


class AccessType(betterproto.Enum):
    UNDEFINED = 0
    NOBODY = 1
    ONLY_ADDRESS = 2
    EVERYBODY = 3


class ContractCodeHistoryOperationType(betterproto.Enum):
    """ContractCodeHistoryOperationType actions that caused a code change"""

    # ContractCodeHistoryOperationTypeUnspecified placeholder for empty value
    CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED = 0
    # ContractCodeHistoryOperationTypeInit on chain contract instantiation
    CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT = 1
    # ContractCodeHistoryOperationTypeMigrate code migration
    CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE = 2
    # ContractCodeHistoryOperationTypeGenesis based on genesis data
    CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS = 3


@dataclass
class MsgStoreCode(betterproto.Message):
    # // sender is the canonical address of the sender bytes sender = 1 [
    # (gogoproto.casttype) =                        "github.com/cosmos/cosmos-
    # sdk/types.AccAddress" ]; Sender is the actor that signed the messages
    sender: str = betterproto.string_field(1)
    # WASMByteCode can be raw or gzip compressed
    wasm_byte_code: bytes = betterproto.bytes_field(2)
    # Source is a valid absolute HTTPS URI to the contract's source code,
    # optional
    source: str = betterproto.string_field(3)
    # Builder is a valid docker image name with tag, optional
    builder: str = betterproto.string_field(4)


@dataclass
class MsgStoreCodeResponse(betterproto.Message):
    """MsgStoreCodeResponse returns store result data."""

    # CodeID is the reference to the stored WASM code
    code_id: int = betterproto.uint64_field(1)


@dataclass
class MsgInstantiateContract(betterproto.Message):
    # sender is the canonical address of the sender string sender = 1 [
    # (cosmos_proto.scalar) = "cosmos.AddressString" ];
    sender: bytes = betterproto.bytes_field(1)
    callback_code_hash: str = betterproto.string_field(2)
    code_id: int = betterproto.uint64_field(3)
    label: str = betterproto.string_field(4)
    # init_msg is an encrypted input to pass to the contract on init
    init_msg: bytes = betterproto.bytes_field(5)
    init_funds: List[v1beta1.Coin] = betterproto.message_field(6)
    # used internally for encryption, should always be empty in a signed
    # transaction
    callback_sig: bytes = betterproto.bytes_field(7)
    # Admin is an optional address that can execute migrations
    admin: str = betterproto.string_field(8)
    # To get the message signer define sender_address as human adress for sender,
    # as a work around without the need to modify cosmwasm valiation logic
    sender_address: str = betterproto.string_field(9)


@dataclass
class MsgInstantiateContractResponse(betterproto.Message):
    """MsgInstantiateContractResponse return instantiation result data"""

    # Address is the bech32 address of the new contract instance.
    address: str = betterproto.string_field(1)
    # Data contains base64-encoded bytes to returned from the contract
    data: bytes = betterproto.bytes_field(2)


@dataclass
class MsgExecuteContract(betterproto.Message):
    # sender is the canonical address of the sender
    sender: bytes = betterproto.bytes_field(1)
    # contract is the canonical address of the contract
    contract: bytes = betterproto.bytes_field(2)
    # msg is an encrypted input to pass to the contract on execute
    msg: bytes = betterproto.bytes_field(3)
    # used internally for encryption, should always be empty in a signed
    # transaction
    callback_code_hash: str = betterproto.string_field(4)
    sent_funds: List[v1beta1.Coin] = betterproto.message_field(5)
    # used internally for encryption, should always be empty in a signed
    # transaction
    callback_sig: bytes = betterproto.bytes_field(6)
    sender_address: str = betterproto.string_field(7)


@dataclass
class MsgExecuteContractResponse(betterproto.Message):
    """MsgExecuteContractResponse returns execution result data."""

    # Data contains base64-encoded bytes to returned from the contract
    data: bytes = betterproto.bytes_field(1)


@dataclass
class MsgMigrateContract(betterproto.Message):
    """
    MsgMigrateContract runs a code upgrade/ downgrade for a smart contract
    """

    # Sender is the that actor that signed the messages
    sender: str = betterproto.string_field(1)
    # Contract is the address of the smart contract
    contract: str = betterproto.string_field(2)
    # CodeID references the new WASM code
    code_id: int = betterproto.uint64_field(3)
    # msg is an encrypted input to pass to the contract on migration
    msg: bytes = betterproto.bytes_field(4)
    # used internally for encryption, should always be empty in a signed
    # transaction
    callback_sig: bytes = betterproto.bytes_field(7)
    # used internally for encryption, should always be empty in a signed
    # transaction
    callback_code_hash: str = betterproto.string_field(8)


@dataclass
class MsgMigrateContractResponse(betterproto.Message):
    """MsgMigrateContractResponse returns contract migration result data."""

    # Data contains same raw bytes returned as data from the wasm contract. (May
    # be empty)
    data: bytes = betterproto.bytes_field(1)


@dataclass
class MsgUpdateAdmin(betterproto.Message):
    """MsgUpdateAdmin sets a new admin for a smart contract"""

    # Sender is the that actor that signed the messages
    sender: str = betterproto.string_field(1)
    # NewAdmin address to be set
    new_admin: str = betterproto.string_field(2)
    # Contract is the address of the smart contract
    contract: str = betterproto.string_field(3)
    # used internally for encryption, should always be empty in a signed
    # transaction
    callback_sig: bytes = betterproto.bytes_field(7)


@dataclass
class MsgUpdateAdminResponse(betterproto.Message):
    """MsgUpdateAdminResponse returns empty data"""

    pass


@dataclass
class MsgClearAdmin(betterproto.Message):
    """MsgClearAdmin removes any admin stored for a smart contract"""

    # Sender is the that actor that signed the messages
    sender: str = betterproto.string_field(1)
    # Contract is the address of the smart contract
    contract: str = betterproto.string_field(3)
    # used internally for encryption, should always be empty in a signed
    # transaction
    callback_sig: bytes = betterproto.bytes_field(7)


@dataclass
class MsgClearAdminResponse(betterproto.Message):
    """MsgClearAdminResponse returns empty data"""

    pass


@dataclass
class AccessTypeParam(betterproto.Message):
    value: "AccessType" = betterproto.enum_field(1)


@dataclass
class CodeInfo(betterproto.Message):
    """CodeInfo is data for the uploaded contract WASM code"""

    code_hash: bytes = betterproto.bytes_field(1)
    creator: bytes = betterproto.bytes_field(2)
    source: str = betterproto.string_field(3)
    builder: str = betterproto.string_field(4)


@dataclass
class ContractKey(betterproto.Message):
    og_contract_key: bytes = betterproto.bytes_field(1)
    current_contract_key: bytes = betterproto.bytes_field(2)
    current_contract_key_proof: bytes = betterproto.bytes_field(3)


@dataclass
class ContractCustomInfo(betterproto.Message):
    enclave_key: "ContractKey" = betterproto.message_field(1)
    label: str = betterproto.string_field(2)


@dataclass
class ContractInfo(betterproto.Message):
    """ContractInfo stores a WASM contract instance"""

    # CodeID is the reference to the stored Wasm code
    code_id: int = betterproto.uint64_field(1)
    # Creator address who initially instantiated the contract
    creator: bytes = betterproto.bytes_field(2)
    # Label is mandatory metadata to be stored with a contract instance.
    label: str = betterproto.string_field(4)
    # Created Tx position when the contract was instantiated.
    created: "AbsoluteTxPosition" = betterproto.message_field(5)
    ibc_port_id: str = betterproto.string_field(6)
    # Admin is an optional address that can execute migrations
    admin: str = betterproto.string_field(7)
    # Proof that enclave executed the instantiate command
    admin_proof: bytes = betterproto.bytes_field(8)


@dataclass
class AbsoluteTxPosition(betterproto.Message):
    """AbsoluteTxPosition can be used to sort contracts"""

    # BlockHeight is the block the contract was created at
    block_height: int = betterproto.int64_field(1)
    # TxIndex is a monotonic counter within the block (actual transaction index,
    # or gas consumed)
    tx_index: int = betterproto.uint64_field(2)


@dataclass
class Model(betterproto.Message):
    """Model is a struct that holds a KV pair"""

    # hex-encode key to read it better (this is often ascii)
    key: bytes = betterproto.bytes_field(1)
    # base64-encode raw value
    value: bytes = betterproto.bytes_field(2)


@dataclass
class ContractCodeHistoryEntry(betterproto.Message):
    """ContractCodeHistoryEntry metadata to a contract."""

    operation: "ContractCodeHistoryOperationType" = betterproto.enum_field(1)
    # CodeID is the reference to the stored WASM code
    code_id: int = betterproto.uint64_field(2)
    # Updated Tx position when the operation was executed.
    updated: "AbsoluteTxPosition" = betterproto.message_field(3)
    msg: bytes = betterproto.bytes_field(4)


@dataclass
class GenesisState(betterproto.Message):
    """GenesisState - genesis state of x/wasm"""

    # Params params = 1 [(gogoproto.nullable) = false];
    codes: List["Code"] = betterproto.message_field(2)
    contracts: List["Contract"] = betterproto.message_field(3)
    sequences: List["Sequence"] = betterproto.message_field(4)


@dataclass
class Code(betterproto.Message):
    """Code struct encompasses CodeInfo and CodeBytes"""

    code_id: int = betterproto.uint64_field(1)
    code_info: "CodeInfo" = betterproto.message_field(2)
    code_bytes: bytes = betterproto.bytes_field(3)


@dataclass
class Contract(betterproto.Message):
    """
    Contract struct encompasses ContractAddress, ContractInfo, and
    ContractState
    """

    contract_address: bytes = betterproto.bytes_field(1)
    contract_info: "ContractInfo" = betterproto.message_field(2)
    contract_state: List["Model"] = betterproto.message_field(3)
    contract_custom_info: "ContractCustomInfo" = betterproto.message_field(4)


@dataclass
class Sequence(betterproto.Message):
    """Sequence id and value of a counter"""

    id_key: bytes = betterproto.bytes_field(1)
    value: int = betterproto.uint64_field(2)


@dataclass
class QuerySecretContractRequest(betterproto.Message):
    # address is the bech32 human readable address of the contract
    contract_address: str = betterproto.string_field(1)
    query: bytes = betterproto.bytes_field(2)


@dataclass
class QueryByLabelRequest(betterproto.Message):
    label: str = betterproto.string_field(1)


@dataclass
class QueryByContractAddressRequest(betterproto.Message):
    # address is the bech32 human readable address of the contract
    contract_address: str = betterproto.string_field(1)


@dataclass
class QueryByCodeIdRequest(betterproto.Message):
    code_id: int = betterproto.uint64_field(1)


@dataclass
class QuerySecretContractResponse(betterproto.Message):
    data: bytes = betterproto.bytes_field(1)


@dataclass
class QueryContractInfoResponse(betterproto.Message):
    """
    QueryContractInfoResponse is the response type for the Query/ContractInfo
    RPC method
    """

    # contract_address is the bech32 human readable address of the contract
    contract_address: str = betterproto.string_field(1)
    contract_info: "ContractInfo" = betterproto.message_field(2)


@dataclass
class ContractInfoWithAddress(betterproto.Message):
    """
    ContractInfoWithAddress adds the contract address to the ContractInfo
    representation
    """

    # contract_address is the bech32 human readable address of the contract
    contract_address: str = betterproto.string_field(1)
    contract_info: "ContractInfo" = betterproto.message_field(2)


@dataclass
class QueryContractsByCodeIdResponse(betterproto.Message):
    contract_infos: List["ContractInfoWithAddress"] = betterproto.message_field(1)


@dataclass
class CodeInfoResponse(betterproto.Message):
    code_id: int = betterproto.uint64_field(1)
    # creator is the bech32 human readable address of the contract
    creator: str = betterproto.string_field(2)
    code_hash: str = betterproto.string_field(3)
    source: str = betterproto.string_field(4)
    builder: str = betterproto.string_field(5)


@dataclass
class QueryCodeResponse(betterproto.Message):
    code_info: "CodeInfoResponse" = betterproto.message_field(1)
    wasm: bytes = betterproto.bytes_field(2)


@dataclass
class QueryCodesResponse(betterproto.Message):
    code_infos: List["CodeInfoResponse"] = betterproto.message_field(1)


@dataclass
class QueryContractAddressResponse(betterproto.Message):
    # address is the bech32 human readable address of the contract
    contract_address: str = betterproto.string_field(1)


@dataclass
class QueryContractLabelResponse(betterproto.Message):
    label: str = betterproto.string_field(1)


@dataclass
class QueryCodeHashResponse(betterproto.Message):
    code_hash: str = betterproto.string_field(1)


@dataclass
class DecryptedAnswer(betterproto.Message):
    """DecryptedAnswer is a struct that represents a decrypted tx-query"""

    type: str = betterproto.string_field(1)
    input: str = betterproto.string_field(2)
    output_data: str = betterproto.string_field(3)
    output_data_as_string: str = betterproto.string_field(4)


@dataclass
class DecryptedAnswers(betterproto.Message):
    answers: List["DecryptedAnswer"] = betterproto.message_field(1)
    output_logs: List[v1beta1.StringEvent] = betterproto.message_field(2)
    output_error: str = betterproto.string_field(3)
    plaintext_error: str = betterproto.string_field(4)


@dataclass
class QueryContractHistoryRequest(betterproto.Message):
    """
    QueryContractHistoryRequest is the request type for the
    Query/ContractHistory RPC method
    """

    # address is the address of the contract to query
    contract_address: str = betterproto.string_field(1)


@dataclass
class QueryContractHistoryResponse(betterproto.Message):
    """
    QueryContractHistoryResponse is the response type for the
    Query/ContractHistory RPC method
    """

    entries: List["ContractCodeHistoryEntry"] = betterproto.message_field(1)


class MsgStub(betterproto.ServiceStub):
    """Msg defines the wasm Msg service."""

    async def store_code(
        self,
        *,
        sender: str = "",
        wasm_byte_code: bytes = b"",
        source: str = "",
        builder: str = "",
    ) -> MsgStoreCodeResponse:
        """StoreCode to submit Wasm code to the system"""

        request = MsgStoreCode()
        request.sender = sender
        request.wasm_byte_code = wasm_byte_code
        request.source = source
        request.builder = builder

        return await self._unary_unary(
            "/secret.compute.v1beta1.Msg/StoreCode",
            request,
            MsgStoreCodeResponse,
        )

    async def instantiate_contract(
        self,
        *,
        sender: bytes = b"",
        callback_code_hash: str = "",
        code_id: int = 0,
        label: str = "",
        init_msg: bytes = b"",
        init_funds: List[v1beta1.Coin] = [],
        callback_sig: bytes = b"",
        admin: str = "",
        sender_address: str = "",
    ) -> MsgInstantiateContractResponse:
        """
        Instantiate creates a new smart contract instance for the given code
        id.
        """

        request = MsgInstantiateContract()
        request.sender = sender
        request.callback_code_hash = callback_code_hash
        request.code_id = code_id
        request.label = label
        request.init_msg = init_msg
        if init_funds is not None:
            request.init_funds = init_funds
        request.callback_sig = callback_sig
        request.admin = admin
        request.sender_address = sender_address

        return await self._unary_unary(
            "/secret.compute.v1beta1.Msg/InstantiateContract",
            request,
            MsgInstantiateContractResponse,
        )

    async def execute_contract(
        self,
        *,
        sender: bytes = b"",
        contract: bytes = b"",
        msg: bytes = b"",
        callback_code_hash: str = "",
        sent_funds: List[v1beta1.Coin] = [],
        callback_sig: bytes = b"",
        sender_address: str = "",
    ) -> MsgExecuteContractResponse:
        """Execute submits the given message data to a smart contract"""

        request = MsgExecuteContract()
        request.sender = sender
        request.contract = contract
        request.msg = msg
        request.callback_code_hash = callback_code_hash
        if sent_funds is not None:
            request.sent_funds = sent_funds
        request.callback_sig = callback_sig
        request.sender_address = sender_address

        return await self._unary_unary(
            "/secret.compute.v1beta1.Msg/ExecuteContract",
            request,
            MsgExecuteContractResponse,
        )

    async def migrate_contract(
        self,
        *,
        sender: str = "",
        contract: str = "",
        code_id: int = 0,
        msg: bytes = b"",
        callback_sig: bytes = b"",
        callback_code_hash: str = "",
    ) -> MsgMigrateContractResponse:
        """Migrate runs a code upgrade/ downgrade for a smart contract"""

        request = MsgMigrateContract()
        request.sender = sender
        request.contract = contract
        request.code_id = code_id
        request.msg = msg
        request.callback_sig = callback_sig
        request.callback_code_hash = callback_code_hash

        return await self._unary_unary(
            "/secret.compute.v1beta1.Msg/MigrateContract",
            request,
            MsgMigrateContractResponse,
        )

    async def update_admin(
        self,
        *,
        sender: str = "",
        new_admin: str = "",
        contract: str = "",
        callback_sig: bytes = b"",
    ) -> MsgUpdateAdminResponse:
        """UpdateAdmin sets a new   admin for a smart contract"""

        request = MsgUpdateAdmin()
        request.sender = sender
        request.new_admin = new_admin
        request.contract = contract
        request.callback_sig = callback_sig

        return await self._unary_unary(
            "/secret.compute.v1beta1.Msg/UpdateAdmin",
            request,
            MsgUpdateAdminResponse,
        )

    async def clear_admin(
        self, *, sender: str = "", contract: str = "", callback_sig: bytes = b""
    ) -> MsgClearAdminResponse:
        """ClearAdmin removes any admin stored for a smart contract"""

        request = MsgClearAdmin()
        request.sender = sender
        request.contract = contract
        request.callback_sig = callback_sig

        return await self._unary_unary(
            "/secret.compute.v1beta1.Msg/ClearAdmin",
            request,
            MsgClearAdminResponse,
        )


class QueryStub(betterproto.ServiceStub):
    """Query defines the gRPC querier service"""

    async def contract_info(
        self, *, contract_address: str = ""
    ) -> QueryContractInfoResponse:
        """Query contract info by address"""

        request = QueryByContractAddressRequest()
        request.contract_address = contract_address

        return await self._unary_unary(
            "/secret.compute.v1beta1.Query/ContractInfo",
            request,
            QueryContractInfoResponse,
        )

    async def contracts_by_code_id(
        self, *, code_id: int = 0
    ) -> QueryContractsByCodeIdResponse:
        """Query code info by id"""

        request = QueryByCodeIdRequest()
        request.code_id = code_id

        return await self._unary_unary(
            "/secret.compute.v1beta1.Query/ContractsByCodeId",
            request,
            QueryContractsByCodeIdResponse,
        )

    async def query_secret_contract(
        self, *, contract_address: str = "", query: bytes = b""
    ) -> QuerySecretContractResponse:
        """Query secret contract"""

        request = QuerySecretContractRequest()
        request.contract_address = contract_address
        request.query = query

        return await self._unary_unary(
            "/secret.compute.v1beta1.Query/QuerySecretContract",
            request,
            QuerySecretContractResponse,
        )

    async def code(self, *, code_id: int = 0) -> QueryCodeResponse:
        """Query a specific contract code by id"""

        request = QueryByCodeIdRequest()
        request.code_id = code_id

        return await self._unary_unary(
            "/secret.compute.v1beta1.Query/Code",
            request,
            QueryCodeResponse,
        )

    async def codes(self) -> QueryCodesResponse:
        """Query all contract codes on-chain"""

        request = protobuf.Empty()

        return await self._unary_unary(
            "/secret.compute.v1beta1.Query/Codes",
            request,
            QueryCodesResponse,
        )

    async def code_hash_by_contract_address(
        self, *, contract_address: str = ""
    ) -> QueryCodeHashResponse:
        """Query code hash by contract address"""

        request = QueryByContractAddressRequest()
        request.contract_address = contract_address

        return await self._unary_unary(
            "/secret.compute.v1beta1.Query/CodeHashByContractAddress",
            request,
            QueryCodeHashResponse,
        )

    async def code_hash_by_code_id(self, *, code_id: int = 0) -> QueryCodeHashResponse:
        """Query code hash by code id"""

        request = QueryByCodeIdRequest()
        request.code_id = code_id

        return await self._unary_unary(
            "/secret.compute.v1beta1.Query/CodeHashByCodeId",
            request,
            QueryCodeHashResponse,
        )

    async def label_by_address(
        self, *, contract_address: str = ""
    ) -> QueryContractLabelResponse:
        """Query contract label by address"""

        request = QueryByContractAddressRequest()
        request.contract_address = contract_address

        return await self._unary_unary(
            "/secret.compute.v1beta1.Query/LabelByAddress",
            request,
            QueryContractLabelResponse,
        )

    async def address_by_label(
        self, *, label: str = ""
    ) -> QueryContractAddressResponse:
        """Query contract address by label"""

        request = QueryByLabelRequest()
        request.label = label

        return await self._unary_unary(
            "/secret.compute.v1beta1.Query/AddressByLabel",
            request,
            QueryContractAddressResponse,
        )

    async def contract_history(
        self, *, contract_address: str = ""
    ) -> QueryContractHistoryResponse:
        """ContractHistory gets the contract code history"""

        request = QueryContractHistoryRequest()
        request.contract_address = contract_address

        return await self._unary_unary(
            "/secret.compute.v1beta1.Query/ContractHistory",
            request,
            QueryContractHistoryResponse,
        )
